/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 36.7.0 Wed Jan 11 12:04:43 2023.
 */

#ifndef BMS_H
#define BMS_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define BMS_BMS_POWER_PREDICTION_FRAME_ID (0x33bu)
#define BMS_BMS_FLUID_MEAS_USER_SOC_FRAME_ID (0x33au)
#define BMS_BMS_STRING_VOLTAGES_FRAME_ID (0x339u)
#define BMS_BMS_MODULE_TEMPERATURES_FRAME_ID (0x337u)
#define BMS_SC01_STATE_FRAME_ID (0x1fu)
#define BMS_BMS_CHARGE_FRAME_ID (0x333u)
#define BMS_BMS_ISOLATION_SOC_FRAME_ID (0x336u)
#define BMS_BMS_ENERGY_SOH_FRAME_ID (0x334u)
#define BMS_BMS_BRICK_VOLTAGES_FRAME_ID (0x335u)
#define BMS_BMS_DRIVE_LIMITS_FRAME_ID (0x332u)
#define BMS_BMS_STATE_FRAME_ID (0x11au)
#define BMS_BMS_CURRENT_VOLTAGE_FRAME_ID (0x331u)
#define BMS_PT_REQUEST_FRAME_ID (0x11bu)

/* Frame lengths in bytes. */
#define BMS_BMS_POWER_PREDICTION_LENGTH (8u)
#define BMS_BMS_FLUID_MEAS_USER_SOC_LENGTH (8u)
#define BMS_BMS_STRING_VOLTAGES_LENGTH (8u)
#define BMS_BMS_MODULE_TEMPERATURES_LENGTH (7u)
#define BMS_SC01_STATE_LENGTH (5u)
#define BMS_BMS_CHARGE_LENGTH (4u)
#define BMS_BMS_ISOLATION_SOC_LENGTH (8u)
#define BMS_BMS_ENERGY_SOH_LENGTH (8u)
#define BMS_BMS_BRICK_VOLTAGES_LENGTH (8u)
#define BMS_BMS_DRIVE_LIMITS_LENGTH (8u)
#define BMS_BMS_STATE_LENGTH (5u)
#define BMS_BMS_CURRENT_VOLTAGE_LENGTH (8u)
#define BMS_PT_REQUEST_LENGTH (7u)

/* Extended or standard frame types. */
#define BMS_BMS_POWER_PREDICTION_IS_EXTENDED (0)
#define BMS_BMS_FLUID_MEAS_USER_SOC_IS_EXTENDED (0)
#define BMS_BMS_STRING_VOLTAGES_IS_EXTENDED (0)
#define BMS_BMS_MODULE_TEMPERATURES_IS_EXTENDED (0)
#define BMS_SC01_STATE_IS_EXTENDED (0)
#define BMS_BMS_CHARGE_IS_EXTENDED (0)
#define BMS_BMS_ISOLATION_SOC_IS_EXTENDED (0)
#define BMS_BMS_ENERGY_SOH_IS_EXTENDED (0)
#define BMS_BMS_BRICK_VOLTAGES_IS_EXTENDED (0)
#define BMS_BMS_DRIVE_LIMITS_IS_EXTENDED (0)
#define BMS_BMS_STATE_IS_EXTENDED (0)
#define BMS_BMS_CURRENT_VOLTAGE_IS_EXTENDED (0)
#define BMS_PT_REQUEST_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define BMS_BMS_POWER_PREDICTION_CYCLE_TIME_MS (100u)
#define BMS_BMS_FLUID_MEAS_USER_SOC_CYCLE_TIME_MS (1000u)
#define BMS_BMS_STRING_VOLTAGES_CYCLE_TIME_MS (100u)
#define BMS_BMS_MODULE_TEMPERATURES_CYCLE_TIME_MS (100u)
#define BMS_SC01_STATE_CYCLE_TIME_MS (100u)
#define BMS_BMS_CHARGE_CYCLE_TIME_MS (100u)
#define BMS_BMS_ISOLATION_SOC_CYCLE_TIME_MS (1000u)
#define BMS_BMS_ENERGY_SOH_CYCLE_TIME_MS (1000u)
#define BMS_BMS_BRICK_VOLTAGES_CYCLE_TIME_MS (100u)
#define BMS_BMS_DRIVE_LIMITS_CYCLE_TIME_MS (10u)
#define BMS_BMS_STATE_CYCLE_TIME_MS (10u)
#define BMS_BMS_CURRENT_VOLTAGE_CYCLE_TIME_MS (10u)
#define BMS_PT_REQUEST_CYCLE_TIME_MS (10u)

/* Signal choices. */
#define BMS_BMS_POWER_PREDICTION_REGEN_CURRENT_PRED_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_POWER_PREDICTION_DISCHARGE_CURRENT_PRED_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_POWER_PREDICTION_REGEN_POWER_PRED_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_POWER_PREDICTION_DISCHARGE_POWER_PRED_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_FLUID_MEAS_USER_SOC_FLUID_TEMPERATURE_INLET_BMS_SNA_CHOICE (255u)

#define BMS_BMS_FLUID_MEAS_USER_SOC_FLUID_TEMPERATURE_OUTLET_BMS_SNA_CHOICE (255u)

#define BMS_BMS_FLUID_MEAS_USER_SOC_USER_SOC_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_FLUID_MEAS_USER_SOC_FLUID_PRESSURE_INLET_BMS_SNA_CHOICE (255u)

#define BMS_BMS_STRING_VOLTAGES_MIN_STRING_VOLTAGE_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_STRING_VOLTAGES_MAX_STRING_VOLTAGE_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_STRING_VOLTAGES_LINK_VOLTAGE_AUXILIARY1_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_STRING_VOLTAGES_LINK_VOLTAGE_AUXILIARY2_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_MODULE_TEMPERATURES_MIN_MODULE_TEMPERATURE_BMS_SNA_CHOICE (255u)

#define BMS_BMS_MODULE_TEMPERATURES_MAX_MODULE_TEMPERATURE_BMS_SNA_CHOICE (255u)

#define BMS_BMS_MODULE_TEMPERATURES_MIN_MODULE_TEMPERATURE_INDEX_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_MODULE_TEMPERATURES_MAX_MODULE_TEMPERATURE_INDEX_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_MODULE_TEMPERATURES_MAX_DEW_POINT_TEMPERATURE_BMS_SNA_CHOICE (255u)

#define BMS_SC01_STATE_LINK_VOLTAGE_SC01_SNA_CHOICE (65535u)

#define BMS_SC01_STATE_EMERGENCY_REQUEST_SC01_EMERGENCY_STATE_INACTIVE_CHOICE (0u)
#define BMS_SC01_STATE_EMERGENCY_REQUEST_SC01_EMERGENCY_STATE_ACTIVE_CHOICE (1u)
#define BMS_SC01_STATE_EMERGENCY_REQUEST_SC01_EMERGENCY_STATE_INVALID_CHOICE (15u)

#define BMS_BMS_CHARGE_CHARGE_CURRENT_SETPOINT_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_CHARGE_CHARGE_VOLTAGE_LIMIT_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_ISOLATION_SOC_ISOLATION_RESISTANCE_EXTERN_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_ISOLATION_SOC_ISOLATION_RESISTANCE_INTERN_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_ISOLATION_SOC_MIN_SOC_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_ISOLATION_SOC_MAX_SOC_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_ENERGY_SOH_ENERGY_AVAILABLE_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_ENERGY_SOH_MIN_SOH_BMS_SNA_CHOICE (255u)

#define BMS_BMS_ENERGY_SOH_MAX_SOH_BMS_SNA_CHOICE (255u)

#define BMS_BMS_BRICK_VOLTAGES_MIN_BRICK_VOLTAGE_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_BRICK_VOLTAGES_MAX_BRICK_VOLTAGE_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_BRICK_VOLTAGES_MIN_BRICK_VOLTAGE_INDEX_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_BRICK_VOLTAGES_MAX_BRICK_VOLTAGE_INDEX_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_DRIVE_LIMITS_MAX_VOLTAGE_LIMIT_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_DRIVE_LIMITS_MIN_VOLTAGE_LIMIT_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_DRIVE_LIMITS_REGEN_CURRENT_LIMIT_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_DRIVE_LIMITS_DISCHARGE_CURRENT_LIMIT_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_STATE_ISOLATION_STATE_BMS_ISOLATION_INACTIVE_CHOICE (0u)
#define BMS_BMS_STATE_ISOLATION_STATE_BMS_ISOLATION_ACTIVE_CHOICE (1u)
#define BMS_BMS_STATE_ISOLATION_STATE_BMS_ISOLATION_INVALID_CHOICE (2u)

#define BMS_BMS_STATE_CHARGE_STATE_BMS_CHARGESTATE_NOTCOMPLETE_CHOICE (0u)
#define BMS_BMS_STATE_CHARGE_STATE_BMS_CHARGESTATE_COMPLETE_CHOICE (1u)
#define BMS_BMS_STATE_CHARGE_STATE_BMS_CHARGESTATE_INVALID_CHOICE (3u)

#define BMS_BMS_STATE_STATE_BMS_STATE_STANDBY_CHOICE (0u)
#define BMS_BMS_STATE_STATE_BMS_STATE_DRIVE_CHOICE (1u)
#define BMS_BMS_STATE_STATE_BMS_STATE_CHARGE_CHOICE (2u)
#define BMS_BMS_STATE_STATE_BMS_STATE_ACCESSORY_CHOICE (3u)
#define BMS_BMS_STATE_STATE_BMS_STATE_LIMPHOME_CHOICE (4u)
#define BMS_BMS_STATE_STATE_BMS_STATE_STRING_FAULT_CHOICE (5u)
#define BMS_BMS_STATE_STATE_BMS_STATE_ESS_FAULT_CHOICE (6u)
#define BMS_BMS_STATE_STATE_BMS_STATE_INVALID_CHOICE (15u)

#define BMS_BMS_STATE_NUMBER_OF_CONNECTED_STRINGS_BMS_SNA_CHOICE (15u)

#define BMS_BMS_STATE_ISOLATION_ERROR_BMS_ISOLATION_OK_CHOICE (0u)
#define BMS_BMS_STATE_ISOLATION_ERROR_BMS_ISOLATION_WARNING_CHOICE (1u)
#define BMS_BMS_STATE_ISOLATION_ERROR_BMS_ISOLATION_ERROR_CHOICE (2u)
#define BMS_BMS_STATE_ISOLATION_ERROR_BMS_SNA_CHOICE (3u)

#define BMS_BMS_STATE_HVIL_STATE_BMS_HVIL_OK_CHOICE (0u)
#define BMS_BMS_STATE_HVIL_STATE_BMS_HVIL_ERROR_CHOICE (1u)
#define BMS_BMS_STATE_HVIL_STATE_BMS_SNA_CHOICE (15u)

#define BMS_BMS_STATE_STATE_TR_BMS_STATE_TRD_OK_CHOICE (0u)
#define BMS_BMS_STATE_STATE_TR_BMS_STATE_TRD_WARNING_CHOICE (1u)
#define BMS_BMS_STATE_STATE_TR_BMS_STATE_TRD_ERROR_CHOICE (2u)
#define BMS_BMS_STATE_STATE_TR_BMS_STATE_INVALID_CHOICE (15u)

#define BMS_BMS_STATE_CNTR_STATE_AUX4_BMS_CTR_OFF_CHOICE (0u)
#define BMS_BMS_STATE_CNTR_STATE_AUX4_BMS_CTR_ON_CHOICE (1u)
#define BMS_BMS_STATE_CNTR_STATE_AUX4_BMS_CTR_OPENING_CHOICE (2u)
#define BMS_BMS_STATE_CNTR_STATE_AUX4_BMS_CTR_INVALID_CHOICE (3u)

#define BMS_BMS_STATE_CNTR_STATE_AUX3_BMS_CTR_OFF_CHOICE (0u)
#define BMS_BMS_STATE_CNTR_STATE_AUX3_BMS_CTR_ON_CHOICE (1u)
#define BMS_BMS_STATE_CNTR_STATE_AUX3_BMS_CTR_OPENING_CHOICE (2u)
#define BMS_BMS_STATE_CNTR_STATE_AUX3_BMS_CTR_INVALID_CHOICE (3u)

#define BMS_BMS_STATE_CNTR_STATE_AUX2_BMS_CTR_OFF_CHOICE (0u)
#define BMS_BMS_STATE_CNTR_STATE_AUX2_BMS_CTR_ON_CHOICE (1u)
#define BMS_BMS_STATE_CNTR_STATE_AUX2_BMS_CTR_OPENING_CHOICE (2u)
#define BMS_BMS_STATE_CNTR_STATE_AUX2_BMS_CTR_INVALID_CHOICE (3u)

#define BMS_BMS_STATE_CNTR_STATE_AUX1_BMS_CTR_OFF_CHOICE (0u)
#define BMS_BMS_STATE_CNTR_STATE_AUX1_BMS_CTR_ON_CHOICE (1u)
#define BMS_BMS_STATE_CNTR_STATE_AUX1_BMS_CTR_OPENING_CHOICE (2u)
#define BMS_BMS_STATE_CNTR_STATE_AUX1_BMS_CTR_INVALID_CHOICE (3u)

#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_NO_TR_CHOICE (0u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_1_CHOICE (1u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_2_CHOICE (2u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_3_CHOICE (3u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_4_CHOICE (4u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_5_CHOICE (5u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_6_CHOICE (6u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_7_CHOICE (7u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_8_CHOICE (8u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_9__SERIAL__CHOICE (9u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_10__SERIAL__CHOICE (10u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_11__SERIAL__CHOICE (11u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_12__SERIAL__CHOICE (12u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_13__SERIAL__CHOICE (13u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_14__SERIAL__CHOICE (14u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_15__SERIAL__CHOICE (15u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_BMS_16__SERIAL__CHOICE (16u)
#define BMS_BMS_STATE_STATE_TR_INDEX_BMS_SNA_CHOICE (31u)

#define BMS_BMS_CURRENT_VOLTAGE_LINK_VOLTAGE_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_CURRENT_VOLTAGE_CURRENT_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_CURRENT_VOLTAGE_DISCHARGE_CURRENT_RESIDUAL_BMS_SNA_CHOICE (65535u)

#define BMS_BMS_CURRENT_VOLTAGE_REGEN_CURRENT_RESIDUAL_BMS_SNA_CHOICE (65535u)

#define BMS_PT_REQUEST_ISOLATION_REQUEST_PT_ISOLATION_INACTIVE_CHOICE (0u)
#define BMS_PT_REQUEST_ISOLATION_REQUEST_PT_ISOLATION_ACTIVE_CHOICE (1u)
#define BMS_PT_REQUEST_ISOLATION_REQUEST_PT_ISOLATION_INVALID_CHOICE (15u)

#define BMS_PT_REQUEST_STATE_REQUEST_PT_STATE_STANDBY_CHOICE (0u)
#define BMS_PT_REQUEST_STATE_REQUEST_PT_STATE_DRIVE_CHOICE (1u)
#define BMS_PT_REQUEST_STATE_REQUEST_PT_STATE_CHARGE_CHOICE (2u)
#define BMS_PT_REQUEST_STATE_REQUEST_PT_STATE_ACCESSORY_CHOICE (3u)
#define BMS_PT_REQUEST_STATE_REQUEST_PT_STATE_LIMPHOME_CHOICE (4u)
#define BMS_PT_REQUEST_STATE_REQUEST_PT_STATE_STRING_FAULT_CHOICE (5u)
#define BMS_PT_REQUEST_STATE_REQUEST_PT_STATE_ESS_FAULT_CHOICE (6u)
#define BMS_PT_REQUEST_STATE_REQUEST_PT_STATE_INVALID_CHOICE (15u)

#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_SHIPPING_CHOICE (0u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_LIMITED_CHOICE (1u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_MODE415_CHOICE (2u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_MODE4175_CHOICE (3u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_MODE405_CHOICE (4u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_MODE407_CHOICE (5u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_MODESOH1_CHOICE (6u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_MODESOH2_CHOICE (7u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_MODESOH3_CHOICE (8u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_MODESOH4_CHOICE (9u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_MODESOH5_CHOICE (10u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_MODESOH6_CHOICE (11u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_MODESOH7_CHOICE (12u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_MODESOH8_CHOICE (13u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_MAXIMUM_CHOICE (14u)
#define BMS_PT_REQUEST_RANGE_REQUEST_PT_RANGE_INVALID_CHOICE (15u)

#define BMS_PT_REQUEST_SLEEP_REQUEST_PT_SLEEP_INACTIVE_CHOICE (0u)
#define BMS_PT_REQUEST_SLEEP_REQUEST_PT_SLEEP_ACTIVE_CHOICE (1u)
#define BMS_PT_REQUEST_SLEEP_REQUEST_PT_SLEEP_INVALID_CHOICE (15u)

#define BMS_PT_REQUEST_CHARGE_POWER_AVAILABLE_PT_SNA_CHOICE (65535u)

#define BMS_PT_REQUEST_CNTR_REQUEST_AUX4_PT_CNTR_OFF_CHOICE (0u)
#define BMS_PT_REQUEST_CNTR_REQUEST_AUX4_PT_CNTR_ON_CHOICE (1u)

#define BMS_PT_REQUEST_CNTR_REQUEST_AUX3_PT_CNTR_OFF_CHOICE (0u)
#define BMS_PT_REQUEST_CNTR_REQUEST_AUX3_PT_CNTR_ON_CHOICE (1u)

#define BMS_PT_REQUEST_CNTR_REQUEST_AUX2_PT_CNTR_OFF_CHOICE (0u)
#define BMS_PT_REQUEST_CNTR_REQUEST_AUX2_PT_CNTR_ON_CHOICE (1u)

#define BMS_PT_REQUEST_CNTR_REQUEST_AUX1_PT_CNTR_OFF_CHOICE (0u)
#define BMS_PT_REQUEST_CNTR_REQUEST_AUX1_PT_CNTR_ON_CHOICE (1u)

/**
 * Signals in message BMS_PowerPrediction.
 *
 * All signal values are as on the CAN bus.
 */
struct bms_bms_power_prediction_t {
    /**
     * Short term prediction for available regeneration current.
     *
     * Range: 0..64000 (0..3200 A)
     * Scale: 0.05
     * Offset: 0
     */
    uint16_t regen_current_pred_bms;

    /**
     * Short term prediction for available discharge current.
     *
     * Range: 0..64000 (0..3200 A)
     * Scale: 0.05
     * Offset: 0
     */
    uint16_t discharge_current_pred_bms;

    /**
     * Short term prediction for available regeneration power.
     *
     * Range: 0..65000 (0..650 kW)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t regen_power_pred_bms;

    /**
     * Short term prediction for available discharge power.
     *
     * Range: 0..65000 (0..650 kW)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t discharge_power_pred_bms;
};

/**
 * Signals in message BMS_FluidMeasUserSOC.
 *
 * All signal values are as on the CAN bus.
 */
struct bms_bms_fluid_meas_user_soc_t {
    /**
     * Minimum inlet fluid temperature of all strings.
     *
     * Range: 0..250 (-40..85 C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t fluid_temperature_inlet_bms;

    /**
     * Minimum outlet fluid temperature of all strings.
     *
     * Range: 0..250 (-40..85 C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t fluid_temperature_outlet_bms;

    /**
     * Maximum SOC of all strings.
     *
     * Range: 0..10000 (0..100 PCT)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t user_soc_bms;

    /**
     * Maximum measured cooling fluid inlet pressure of all strings.
     *
     * Range: 0..254 (0..2540 mbar)
     * Scale: 10
     * Offset: 0
     */
    uint8_t fluid_pressure_inlet_bms;
};

/**
 * Signals in message BMS_StringVoltages.
 *
 * All signal values are as on the CAN bus.
 */
struct bms_bms_string_voltages_t {
    /**
     * Minimum string voltage of all strings.
     *
     * Range: 0..60000 (0..1200 V)
     * Scale: 0.02
     * Offset: 0
     */
    uint16_t min_string_voltage_bms;

    /**
     * Maximum string voltage of all strings.
     *
     * Range: 0..60000 (0..1200 V)
     * Scale: 0.02
     * Offset: 0
     */
    uint16_t max_string_voltage_bms;

    /**
     * DC link voltage.
     *
     * Range: 0..60000 (0..1200 V)
     * Scale: 0.02
     * Offset: 0
     */
    uint16_t link_voltage_auxiliary1_bms;

    /**
     * DC link voltage.
     *
     * Range: 0..60000 (0..1200 V)
     * Scale: 0.02
     * Offset: 0
     */
    uint16_t link_voltage_auxiliary2_bms;
};

/**
 * Signals in message BMS_ModuleTemperatures.
 *
 * All signal values are as on the CAN bus.
 */
struct bms_bms_module_temperatures_t {
    /**
     * Minimum module temperature of all strings.
     *
     * Range: 0..250 (-40..85 C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t min_module_temperature_bms;

    /**
     * Maximum module temperature of all strings.
     *
     * Range: 0..250 (-40..85 C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t max_module_temperature_bms;

    /**
     * Minimum module temperature index of all strings.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t min_module_temperature_index_bms;

    /**
     * Maximum module termperature index of all strings.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t max_module_temperature_index_bms;

    /**
     * Maximum dew point temperature of all strings
     *
     * Range: 0..250 (-40..85 C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t max_dew_point_temperature_bms;
};

/**
 * Signals in message SC01_State.
 *
 * All signal values are as on the CAN bus.
 */
struct bms_sc01_state_t {
    /**
     * DC link voltage.
     *
     * Range: 0..62500 (-1250..1250 V)
     * Scale: 0.04
     * Offset: -1250
     */
    uint16_t link_voltage_sc01;

    /**
     * Emergency request to shut down all components of the DC bus.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t emergency_request_sc01;

    /**
     * Alive counter.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t alive_sc01;

    /**
     * Cyclic redundancy check.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t crc_sc01;
};

/**
 * Signals in message BMS_Charge.
 *
 * All signal values are as on the CAN bus.
 */
struct bms_bms_charge_t {
    /**
     * DC charge current command. Output of charge control loop.
     *
     * Range: 0..64000 (0..3200 A)
     * Scale: 0.05
     * Offset: 0
     */
    uint16_t charge_current_setpoint_bms;

    /**
     * DC voltage limit for charging.
     *
     * Range: 0..60000 (0..1200 V)
     * Scale: 0.02
     * Offset: 0
     */
    uint16_t charge_voltage_limit_bms;
};

/**
 * Signals in message BMS_IsolationSOC.
 *
 * All signal values are as on the CAN bus.
 */
struct bms_bms_isolation_soc_t {
    /**
     * Isolation resistance of the overall system.
     *
     * Range: 0..65000 (0..130000 kOhm)
     * Scale: 2
     * Offset: 0
     */
    uint16_t isolation_resistance_extern_bms;

    /**
     * Minimum isolation resistance of all strings.
     *
     * Range: 0..65000 (0..130000 kOhm)
     * Scale: 2
     * Offset: 0
     */
    uint16_t isolation_resistance_intern_bms;

    /**
     * Minimum SOC of all strings.
     *
     * Range: 0..10000 (0..100 PCT)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t min_soc_bms;

    /**
     * Maximum SOC of all strings.
     *
     * Range: 0..10000 (0..100 PCT)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t max_soc_bms;
};

/**
 * Signals in message BMS_EnergySOH.
 *
 * All signal values are as on the CAN bus.
 */
struct bms_bms_energy_soh_t {
    /**
     * Energy available of all strings.
     *
     * Range: 0..65000 (0..650 kWh)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t energy_available_bms;

    /**
     * Minimum SOH of all strings.
     *
     * Range: 0..240 (0..120 PCT)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t min_soh_bms;

    /**
     * Maximum SOH of all strings.
     *
     * Range: 0..240 (0..120 PCT)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t max_soh_bms;
};

/**
 * Signals in message BMS_BrickVoltages.
 *
 * All signal values are as on the CAN bus.
 */
struct bms_bms_brick_voltages_t {
    /**
     * Minimum brick voltage of all strings.
     *
     * Range: 0..65000 (0..6.5 V)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t min_brick_voltage_bms;

    /**
     * Maximum brick voltage of all strings.
     *
     * Range: 0..65000 (0..6.5 V)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t max_brick_voltage_bms;

    /**
     * Minimum brick voltage index of all strings.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t min_brick_voltage_index_bms;

    /**
     * Maximum brick voltage index of all strings.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t max_brick_voltage_index_bms;
};

/**
 * Signals in message BMS_DriveLimits.
 *
 * All signal values are as on the CAN bus.
 */
struct bms_bms_drive_limits_t {
    /**
     * Maximum string voltage limit of all strings.
     *
     * Range: 0..60000 (0..1200 V)
     * Scale: 0.02
     * Offset: 0
     */
    uint16_t max_voltage_limit_bms;

    /**
     * Minimum string voltage limit of all strings.
     *
     * Range: 0..60000 (0..1200 V)
     * Scale: 0.02
     * Offset: 0
     */
    uint16_t min_voltage_limit_bms;

    /**
     * Current limit for regenerating of all strings.
     *
     * Range: 0..64000 (0..3200 A)
     * Scale: 0.05
     * Offset: 0
     */
    uint16_t regen_current_limit_bms;

    /**
     * Current limit for discharging of all strings. This is a positive value.
     *
     * Range: 0..64000 (0..3200 A)
     * Scale: 0.05
     * Offset: 0
     */
    uint16_t discharge_current_limit_bms;
};

/**
 * Signals in message BMS_State.
 *
 * All signal values are as on the CAN bus.
 */
struct bms_bms_state_t {
    /**
     * The state of the external/system isolation monitoring. The signal isolationState_BMS shall be set to 0x1 - ISOLATION_ACTIVE, if at least one pack has contactors close and performs isolation testing.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t isolation_state_bms;

    /**
     * Charge state.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t charge_state_bms;

    /**
     * BMS state.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t state_bms;

    /**
     * Number of connected strings.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_connected_strings_bms;

    /**
     * The state of the external/system isolation monitoring. The signal isolationState_BMS shall be set to 0x1 - ISOLATION_ACTIVE, if at least one pack has contactors close and performs isolation testing.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t isolation_error_bms;

    /**
     * The state of the external/system isolation monitoring. The signal isolationState_BMS shall be set to 0x1 - ISOLATION_ACTIVE, if at least one pack has contactors close and performs isolation testing.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t hvil_state_bms;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state_tr_bms;

    /**
     * Auxiliary contactor state.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cntr_state_aux4_bms;

    /**
     * Auxiliary contactor state.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cntr_state_aux3_bms;

    /**
     * Auxiliary contactor state.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cntr_state_aux2_bms;

    /**
     * Auxiliary contactor state.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cntr_state_aux1_bms;

    /**
     * ID of first battery detecting a thermal runaway.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state_tr_index_bms;
};

/**
 * Signals in message BMS_CurrentVoltage.
 *
 * All signal values are as on the CAN bus.
 */
struct bms_bms_current_voltage_t {
    /**
     * DC link voltage.
     *
     * Range: 0..60000 (0..1200 V)
     * Scale: 0.02
     * Offset: 0
     */
    uint16_t link_voltage_bms;

    /**
     * Current of all strings (positive=discharge, negative=charge).
     *
     * Range: 0..64000 (-3200..3200 A)
     * Scale: 0.1
     * Offset: -3200
     */
    uint16_t current_bms;

    /**
     * Minimum difference of discharge current limit and string current of all strings.
     * Positive indicating available discharge current. Negative value indicating discharge current limit violation.
     *
     * Range: 0..64000 (-3200..3200 A)
     * Scale: 0.1
     * Offset: -3200
     */
    uint16_t discharge_current_residual_bms;

    /**
     * Minimum difference of regen current limit and string current of all strings.
     * Positive indicating available regen current. Negative value indicating regen current limit violation.
     *
     * Range: 0..64000 (-3200..3200 A)
     * Scale: 0.1
     * Offset: -3200
     */
    uint16_t regen_current_residual_bms;
};

/**
 * Signals in message PT_Request.
 *
 * All signal values are as on the CAN bus.
 */
struct bms_pt_request_t {
    /**
     * Optional disabling of isolation monitoring.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t isolation_request_pt;

    /**
     * BMS state request.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t state_request_pt;

    /**
     * Range request to command the BMS for different charge targets.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t range_request_pt;

    /**
     * Sleep request to command the BMS to go to sleep mode.
     * Sleep mode can only be entered if key signal is low and no messages on PTCAN present.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sleep_request_pt;

    /**
     * Available power for charging.
     *
     * Range: 0..65000 (0..650 kW)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t charge_power_available_pt;

    /**
     * Alive counter.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t alive_pt;

    /**
     * Auxiliary contactor state request.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cntr_request_aux4_pt;

    /**
     * Auxiliary contactor state request.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cntr_request_aux3_pt;

    /**
     * Auxiliary contactor state request.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cntr_request_aux2_pt;

    /**
     * Auxiliary contactor state request.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cntr_request_aux1_pt;

    /**
     * Cyclic redundancy check.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t crc_pt;
};

/**
 * Pack message BMS_PowerPrediction.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int bms_bms_power_prediction_pack(
    uint8_t *dst_p,
    const struct bms_bms_power_prediction_t *src_p,
    size_t size);

/**
 * Unpack message BMS_PowerPrediction.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int bms_bms_power_prediction_unpack(
    struct bms_bms_power_prediction_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_power_prediction_regen_current_pred_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_power_prediction_regen_current_pred_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_power_prediction_regen_current_pred_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_power_prediction_discharge_current_pred_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_power_prediction_discharge_current_pred_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_power_prediction_discharge_current_pred_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_power_prediction_regen_power_pred_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_power_prediction_regen_power_pred_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_power_prediction_regen_power_pred_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_power_prediction_discharge_power_pred_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_power_prediction_discharge_power_pred_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_power_prediction_discharge_power_pred_bms_is_in_range(uint16_t value);

/**
 * Pack message BMS_FluidMeasUserSOC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int bms_bms_fluid_meas_user_soc_pack(
    uint8_t *dst_p,
    const struct bms_bms_fluid_meas_user_soc_t *src_p,
    size_t size);

/**
 * Unpack message BMS_FluidMeasUserSOC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int bms_bms_fluid_meas_user_soc_unpack(
    struct bms_bms_fluid_meas_user_soc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_fluid_meas_user_soc_fluid_temperature_inlet_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_fluid_meas_user_soc_fluid_temperature_inlet_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_fluid_meas_user_soc_fluid_temperature_inlet_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_fluid_meas_user_soc_fluid_temperature_outlet_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_fluid_meas_user_soc_fluid_temperature_outlet_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_fluid_meas_user_soc_fluid_temperature_outlet_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_fluid_meas_user_soc_user_soc_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_fluid_meas_user_soc_user_soc_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_fluid_meas_user_soc_user_soc_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_fluid_meas_user_soc_fluid_pressure_inlet_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_fluid_meas_user_soc_fluid_pressure_inlet_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_fluid_meas_user_soc_fluid_pressure_inlet_bms_is_in_range(uint8_t value);

/**
 * Pack message BMS_StringVoltages.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int bms_bms_string_voltages_pack(
    uint8_t *dst_p,
    const struct bms_bms_string_voltages_t *src_p,
    size_t size);

/**
 * Unpack message BMS_StringVoltages.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int bms_bms_string_voltages_unpack(
    struct bms_bms_string_voltages_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_string_voltages_min_string_voltage_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_string_voltages_min_string_voltage_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_string_voltages_min_string_voltage_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_string_voltages_max_string_voltage_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_string_voltages_max_string_voltage_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_string_voltages_max_string_voltage_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_string_voltages_link_voltage_auxiliary1_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_string_voltages_link_voltage_auxiliary1_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_string_voltages_link_voltage_auxiliary1_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_string_voltages_link_voltage_auxiliary2_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_string_voltages_link_voltage_auxiliary2_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_string_voltages_link_voltage_auxiliary2_bms_is_in_range(uint16_t value);

/**
 * Pack message BMS_ModuleTemperatures.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int bms_bms_module_temperatures_pack(
    uint8_t *dst_p,
    const struct bms_bms_module_temperatures_t *src_p,
    size_t size);

/**
 * Unpack message BMS_ModuleTemperatures.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int bms_bms_module_temperatures_unpack(
    struct bms_bms_module_temperatures_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_module_temperatures_min_module_temperature_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_module_temperatures_min_module_temperature_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_module_temperatures_min_module_temperature_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_module_temperatures_max_module_temperature_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_module_temperatures_max_module_temperature_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_module_temperatures_max_module_temperature_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_module_temperatures_min_module_temperature_index_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_module_temperatures_min_module_temperature_index_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_module_temperatures_min_module_temperature_index_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_module_temperatures_max_module_temperature_index_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_module_temperatures_max_module_temperature_index_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_module_temperatures_max_module_temperature_index_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_module_temperatures_max_dew_point_temperature_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_module_temperatures_max_dew_point_temperature_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_module_temperatures_max_dew_point_temperature_bms_is_in_range(uint8_t value);

/**
 * Pack message SC01_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int bms_sc01_state_pack(
    uint8_t *dst_p,
    const struct bms_sc01_state_t *src_p,
    size_t size);

/**
 * Unpack message SC01_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int bms_sc01_state_unpack(
    struct bms_sc01_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_sc01_state_link_voltage_sc01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_sc01_state_link_voltage_sc01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_sc01_state_link_voltage_sc01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_sc01_state_emergency_request_sc01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_sc01_state_emergency_request_sc01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_sc01_state_emergency_request_sc01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_sc01_state_alive_sc01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_sc01_state_alive_sc01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_sc01_state_alive_sc01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_sc01_state_crc_sc01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_sc01_state_crc_sc01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_sc01_state_crc_sc01_is_in_range(uint8_t value);

/**
 * Pack message BMS_Charge.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int bms_bms_charge_pack(
    uint8_t *dst_p,
    const struct bms_bms_charge_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Charge.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int bms_bms_charge_unpack(
    struct bms_bms_charge_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_charge_charge_current_setpoint_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_charge_charge_current_setpoint_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_charge_charge_current_setpoint_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_charge_charge_voltage_limit_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_charge_charge_voltage_limit_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_charge_charge_voltage_limit_bms_is_in_range(uint16_t value);

/**
 * Pack message BMS_IsolationSOC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int bms_bms_isolation_soc_pack(
    uint8_t *dst_p,
    const struct bms_bms_isolation_soc_t *src_p,
    size_t size);

/**
 * Unpack message BMS_IsolationSOC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int bms_bms_isolation_soc_unpack(
    struct bms_bms_isolation_soc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_isolation_soc_isolation_resistance_extern_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_isolation_soc_isolation_resistance_extern_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_isolation_soc_isolation_resistance_extern_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_isolation_soc_isolation_resistance_intern_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_isolation_soc_isolation_resistance_intern_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_isolation_soc_isolation_resistance_intern_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_isolation_soc_min_soc_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_isolation_soc_min_soc_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_isolation_soc_min_soc_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_isolation_soc_max_soc_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_isolation_soc_max_soc_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_isolation_soc_max_soc_bms_is_in_range(uint16_t value);

/**
 * Pack message BMS_EnergySOH.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int bms_bms_energy_soh_pack(
    uint8_t *dst_p,
    const struct bms_bms_energy_soh_t *src_p,
    size_t size);

/**
 * Unpack message BMS_EnergySOH.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int bms_bms_energy_soh_unpack(
    struct bms_bms_energy_soh_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_energy_soh_energy_available_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_energy_soh_energy_available_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_energy_soh_energy_available_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_energy_soh_min_soh_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_energy_soh_min_soh_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_energy_soh_min_soh_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_energy_soh_max_soh_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_energy_soh_max_soh_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_energy_soh_max_soh_bms_is_in_range(uint8_t value);

/**
 * Pack message BMS_BrickVoltages.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int bms_bms_brick_voltages_pack(
    uint8_t *dst_p,
    const struct bms_bms_brick_voltages_t *src_p,
    size_t size);

/**
 * Unpack message BMS_BrickVoltages.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int bms_bms_brick_voltages_unpack(
    struct bms_bms_brick_voltages_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_brick_voltages_min_brick_voltage_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_brick_voltages_min_brick_voltage_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_brick_voltages_min_brick_voltage_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_brick_voltages_max_brick_voltage_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_brick_voltages_max_brick_voltage_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_brick_voltages_max_brick_voltage_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_brick_voltages_min_brick_voltage_index_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_brick_voltages_min_brick_voltage_index_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_brick_voltages_min_brick_voltage_index_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_brick_voltages_max_brick_voltage_index_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_brick_voltages_max_brick_voltage_index_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_brick_voltages_max_brick_voltage_index_bms_is_in_range(uint16_t value);

/**
 * Pack message BMS_DriveLimits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int bms_bms_drive_limits_pack(
    uint8_t *dst_p,
    const struct bms_bms_drive_limits_t *src_p,
    size_t size);

/**
 * Unpack message BMS_DriveLimits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int bms_bms_drive_limits_unpack(
    struct bms_bms_drive_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_drive_limits_max_voltage_limit_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_drive_limits_max_voltage_limit_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_drive_limits_max_voltage_limit_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_drive_limits_min_voltage_limit_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_drive_limits_min_voltage_limit_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_drive_limits_min_voltage_limit_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_drive_limits_regen_current_limit_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_drive_limits_regen_current_limit_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_drive_limits_regen_current_limit_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_drive_limits_discharge_current_limit_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_drive_limits_discharge_current_limit_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_drive_limits_discharge_current_limit_bms_is_in_range(uint16_t value);

/**
 * Pack message BMS_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int bms_bms_state_pack(
    uint8_t *dst_p,
    const struct bms_bms_state_t *src_p,
    size_t size);

/**
 * Unpack message BMS_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int bms_bms_state_unpack(
    struct bms_bms_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_state_isolation_state_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_state_isolation_state_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_state_isolation_state_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_state_charge_state_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_state_charge_state_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_state_charge_state_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_state_state_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_state_state_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_state_state_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_state_number_of_connected_strings_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_state_number_of_connected_strings_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_state_number_of_connected_strings_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_state_isolation_error_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_state_isolation_error_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_state_isolation_error_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_state_hvil_state_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_state_hvil_state_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_state_hvil_state_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_state_state_tr_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_state_state_tr_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_state_state_tr_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_state_cntr_state_aux4_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_state_cntr_state_aux4_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_state_cntr_state_aux4_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_state_cntr_state_aux3_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_state_cntr_state_aux3_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_state_cntr_state_aux3_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_state_cntr_state_aux2_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_state_cntr_state_aux2_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_state_cntr_state_aux2_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_state_cntr_state_aux1_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_state_cntr_state_aux1_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_state_cntr_state_aux1_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_bms_state_state_tr_index_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_state_state_tr_index_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_state_state_tr_index_bms_is_in_range(uint8_t value);

/**
 * Pack message BMS_CurrentVoltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int bms_bms_current_voltage_pack(
    uint8_t *dst_p,
    const struct bms_bms_current_voltage_t *src_p,
    size_t size);

/**
 * Unpack message BMS_CurrentVoltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int bms_bms_current_voltage_unpack(
    struct bms_bms_current_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_current_voltage_link_voltage_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_current_voltage_link_voltage_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_current_voltage_link_voltage_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_current_voltage_current_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_current_voltage_current_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_current_voltage_current_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_current_voltage_discharge_current_residual_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_current_voltage_discharge_current_residual_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_current_voltage_discharge_current_residual_bms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_bms_current_voltage_regen_current_residual_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_bms_current_voltage_regen_current_residual_bms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_bms_current_voltage_regen_current_residual_bms_is_in_range(uint16_t value);

/**
 * Pack message PT_Request.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int bms_pt_request_pack(
    uint8_t *dst_p,
    const struct bms_pt_request_t *src_p,
    size_t size);

/**
 * Unpack message PT_Request.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int bms_pt_request_unpack(
    struct bms_pt_request_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_pt_request_isolation_request_pt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_pt_request_isolation_request_pt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_pt_request_isolation_request_pt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_pt_request_state_request_pt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_pt_request_state_request_pt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_pt_request_state_request_pt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_pt_request_range_request_pt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_pt_request_range_request_pt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_pt_request_range_request_pt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_pt_request_sleep_request_pt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_pt_request_sleep_request_pt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_pt_request_sleep_request_pt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t bms_pt_request_charge_power_available_pt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_pt_request_charge_power_available_pt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_pt_request_charge_power_available_pt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_pt_request_alive_pt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_pt_request_alive_pt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_pt_request_alive_pt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_pt_request_cntr_request_aux4_pt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_pt_request_cntr_request_aux4_pt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_pt_request_cntr_request_aux4_pt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_pt_request_cntr_request_aux3_pt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_pt_request_cntr_request_aux3_pt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_pt_request_cntr_request_aux3_pt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_pt_request_cntr_request_aux2_pt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_pt_request_cntr_request_aux2_pt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_pt_request_cntr_request_aux2_pt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_pt_request_cntr_request_aux1_pt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_pt_request_cntr_request_aux1_pt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_pt_request_cntr_request_aux1_pt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t bms_pt_request_crc_pt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double bms_pt_request_crc_pt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool bms_pt_request_crc_pt_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
